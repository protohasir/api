// Code generated by MockGen. DO NOT EDIT.
// Source: hasir-api/internal/organization (interfaces: Queue)
//
// Generated by this command:
//
//	mockgen -package=organization -destination=internal/organization/queue_mock.go hasir-api/internal/organization Queue
//

// Package organization is a generated GoMock package.
package organization

import (
	context "context"
	email "hasir-api/pkg/email"
	reflect "reflect"
	time "time"

	gomock "go.uber.org/mock/gomock"
)

// MockQueue is a mock of Queue interface.
type MockQueue struct {
	ctrl     *gomock.Controller
	recorder *MockQueueMockRecorder
	isgomock struct{}
}

// MockQueueMockRecorder is the mock recorder for MockQueue.
type MockQueueMockRecorder struct {
	mock *MockQueue
}

// NewMockQueue creates a new mock instance.
func NewMockQueue(ctrl *gomock.Controller) *MockQueue {
	mock := &MockQueue{ctrl: ctrl}
	mock.recorder = &MockQueueMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockQueue) EXPECT() *MockQueueMockRecorder {
	return m.recorder
}

// EnqueueEmailJobs mocks base method.
func (m *MockQueue) EnqueueEmailJobs(ctx context.Context, jobs []*EmailJobDTO) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "EnqueueEmailJobs", ctx, jobs)
	ret0, _ := ret[0].(error)
	return ret0
}

// EnqueueEmailJobs indicates an expected call of EnqueueEmailJobs.
func (mr *MockQueueMockRecorder) EnqueueEmailJobs(ctx, jobs any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "EnqueueEmailJobs", reflect.TypeOf((*MockQueue)(nil).EnqueueEmailJobs), ctx, jobs)
}

// GetPendingEmailJobs mocks base method.
func (m *MockQueue) GetPendingEmailJobs(ctx context.Context, limit int) ([]*EmailJobDTO, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GetPendingEmailJobs", ctx, limit)
	ret0, _ := ret[0].([]*EmailJobDTO)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GetPendingEmailJobs indicates an expected call of GetPendingEmailJobs.
func (mr *MockQueueMockRecorder) GetPendingEmailJobs(ctx, limit any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GetPendingEmailJobs", reflect.TypeOf((*MockQueue)(nil).GetPendingEmailJobs), ctx, limit)
}

// Start mocks base method.
func (m *MockQueue) Start(ctx context.Context, emailService email.Service, batchSize int, pollInterval time.Duration) {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Start", ctx, emailService, batchSize, pollInterval)
}

// Start indicates an expected call of Start.
func (mr *MockQueueMockRecorder) Start(ctx, emailService, batchSize, pollInterval any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Start", reflect.TypeOf((*MockQueue)(nil).Start), ctx, emailService, batchSize, pollInterval)
}

// Stop mocks base method.
func (m *MockQueue) Stop() {
	m.ctrl.T.Helper()
	m.ctrl.Call(m, "Stop")
}

// Stop indicates an expected call of Stop.
func (mr *MockQueueMockRecorder) Stop() *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Stop", reflect.TypeOf((*MockQueue)(nil).Stop))
}

// UpdateEmailJobStatus mocks base method.
func (m *MockQueue) UpdateEmailJobStatus(ctx context.Context, jobId string, status EmailJobStatus, errorMsg *string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "UpdateEmailJobStatus", ctx, jobId, status, errorMsg)
	ret0, _ := ret[0].(error)
	return ret0
}

// UpdateEmailJobStatus indicates an expected call of UpdateEmailJobStatus.
func (mr *MockQueueMockRecorder) UpdateEmailJobStatus(ctx, jobId, status, errorMsg any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "UpdateEmailJobStatus", reflect.TypeOf((*MockQueue)(nil).UpdateEmailJobStatus), ctx, jobId, status, errorMsg)
}
